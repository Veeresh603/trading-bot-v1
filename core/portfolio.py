# core/portfolio.py
import pandas as pd
from math import floor
from config import BacktestConfig
from core.utils import logger

class Portfolio:
    """
    Manages the state of the trading account: holdings, cash, and equity.
    Generates orders based on signals and processes filled orders.
    """
    def __init__(self, data_handler, execution_handler, initial_capital):
        self.data_handler = data_handler
        self.execution_handler = execution_handler
        self.initial_capital = initial_capital
        self.current_positions = self._construct_initial_positions()
        self.current_holdings = self._construct_initial_holdings()
        
        self.all_positions = []
        self.all_holdings = []
        
        self._log_initial_state()
        self.trades = []


    def _construct_initial_positions(self):
        """Creates a dictionary to hold the quantity of each symbol."""
        positions = {symbol: 0.0 for symbol in self.data_handler.symbols}
        return positions

    def _construct_initial_holdings(self):
        """Creates a dictionary to hold the market value of cash and assets."""
        holdings = {symbol: 0.0 for symbol in self.data_handler.symbols}
        holdings['cash'] = self.initial_capital
        holdings['commission'] = 0.0
        holdings['total_value'] = self.initial_capital
        return holdings

    def _log_initial_state(self):
        """Adds the initial state to the all_holdings list."""
        initial_state = self.current_holdings.copy()
        initial_state['timestamp'] = self.data_handler.start_date
        self.all_holdings.append(initial_state)

    def update_timeindex(self):
        """
        Updates the portfolio's holdings based on the latest market data.
        This is called at the start of each new bar.
        """
        latest_market_values = {}
        total_market_value = 0
        
        for symbol in self.data_handler.symbols:
            quantity = self.current_positions[symbol]
            price = self.data_handler.get_latest_bar_value(symbol, 'Close')
            market_value = quantity * price
            latest_market_values[symbol] = market_value
            total_market_value += market_value
        
        self.current_holdings['total_value'] = self.current_holdings['cash'] + total_market_value
        for symbol, value in latest_market_values.items():
            self.current_holdings[symbol] = value

        # Log the state for this timestamp
        new_state = self.current_holdings.copy()
        new_state['timestamp'] = self.data_handler.get_latest_bar_datetime()
        self.all_holdings.append(new_state)

    def process_signals(self, signals):
        """
        Acts on signals generated by the Strategy.
        Generates and sends orders to the execution handler.
        """
        for symbol, signal_info in signals.items():
            direction = signal_info['direction']
            confidence = signal_info.get('confidence', 1.0) # Default confidence
            
            current_position = self.current_positions[symbol]
            
            if direction == 'LONG' and current_position == 0:
                quantity = self._calculate_position_size(symbol, confidence)
                if quantity > 0:
                    self.execution_handler.place_order(symbol, quantity, 'BUY')
            
            elif direction == 'EXIT' and current_position > 0:
                quantity = current_position
                self.execution_handler.place_order(symbol, quantity, 'SELL')

    def _calculate_position_size(self, symbol, confidence):
        """Calculates the number of shares to trade based on the sizing method."""
        price = self.data_handler.get_latest_bar_value(symbol, 'Close')
        
        if BacktestConfig.SIZING_METHOD == 'fixed':
            investment_amount = self.current_holdings['total_value'] * BacktestConfig.FIXED_POSITION_SIZE_PCT
            return floor(investment_amount / price)
        
        elif BacktestConfig.SIZING_METHOD == 'kelly' and 0 < confidence < 1:
            # A simplified Kelly Criterion implementation using model confidence
            # This is an advanced concept.
            # Kelly % = P(Win) - (1 - P(Win)) / (Reward/Risk)
            # We use confidence as P(Win) and assume a 1.5 R/R ratio.
            kelly_pct = confidence - ((1 - confidence) / 1.5)
            if kelly_pct <= 0: return 0
            
            investment_amount = self.current_holdings['total_value'] * kelly_pct
            return floor(investment_amount / price)
            
        return 0

    def process_fills(self):
        """
        Processes filled orders from the execution handler, updating
        positions and holdings accordingly.
        """
        while not self.execution_handler.fills_queue.empty():
            fill_event = self.execution_handler.fills_queue.get()
            
            self._update_positions_from_fill(fill_event)
            self._update_holdings_from_fill(fill_event)
            self._log_trade(fill_event)

    def _update_positions_from_fill(self, fill):
        """Updates the quantity of the asset held."""
        fill_dir = 1 if fill['direction'] == 'BUY' else -1
        self.current_positions[fill['symbol']] += fill_dir * fill['quantity']

    def _update_holdings_from_fill(self, fill):
        """Updates cash, commissions, and asset market value."""
        fill_dir = 1 if fill['direction'] == 'BUY' else -1
        cost = fill_dir * fill['fill_price'] * fill['quantity']
        
        self.current_holdings['cash'] -= cost
        self.current_holdings['commission'] += fill['commission']
        self.current_holdings['cash'] -= fill['commission']
        
        # Update asset value immediately after fill
        self.current_holdings[fill['symbol']] = self.current_positions[fill['symbol']] * fill['fill_price']
        self.current_holdings['total_value'] -= fill['commission']
        
    def _log_trade(self, fill):
        """Logs the details of a completed trade."""
        self.trades.append({
            'timestamp': fill['timestamp'],
            'symbol': fill['symbol'],
            'direction': fill['direction'],
            'quantity': fill['quantity'],
            'price': fill['fill_price'],
            'commission': fill['commission']
        })
        logger.info(
            f"TRADE | {fill['timestamp']} | {fill['direction']} {fill['quantity']} {fill['symbol']} "
            f"@ {fill['fill_price']:.2f} | Commission: ${fill['commission']:.2f}"
        )

    def create_results_dataframe(self):
        """Creates a pandas DataFrame from the holdings history."""
        df = pd.DataFrame(self.all_holdings)
        df.set_index('timestamp', inplace=True)
        df['returns'] = df['total_value'].pct_change().fillna(0)
        return df

    @property
    def trades_df(self):
        """Returns a pandas DataFrame of all trades."""
        return pd.DataFrame(self.trades).set_index('timestamp')
